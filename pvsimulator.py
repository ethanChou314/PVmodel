"""
Developer: Hsuan-I (Ethan) Chou
This is a module that generates simulated observational data of a rotating and infalling envelope 
using various adjustable physical assumptions. It also allows users to visualize the simulated 
data onto either 2d PV diagrams (on either major/minor axis) or 3d channel maps. 
"""

# numerical and scientific modules
import numpy as np
import pandas as pd
import scipy as sp
from scipy.ndimage import gaussian_filter
from astropy import constants as const, units as u

# image modules
from matplotlib import pyplot as plt, rcParams, gridspec, patches
import matplotlib as mpl
from mpl_toolkits.axes_grid1 import ImageGrid
from astropy.io import fits
from astropy.wcs import WCS

# other modules
import time
import warnings
import os
import copy


# +
class PVModel:
    def __init__(self, txtfile=None, v=None, x=None, s=None, params=None, **kwargs):
        """
        This is the constructor of the PVModel class. 
        There are three ways to create a PVModel object:
        1. Use the "txtfile" parameter to import the axes from a textfile generated by this module. 
        2. Manually set the vaxis, xaxis, and saxis.
        3. Apply keywords arguments consistent with the 'make_pvmodel' function. 
        """
        if (v is None or x is None or s is None) and txtfile is None:
            self.vaxis, self.xaxis, self.saxis, self.params = make_pvmodel(ret_params=True, **kwargs)
        elif txtfile is not None:
            self.vaxis, self.xaxis, self.saxis = import_data(txtfile)
            try:
                self.params = import_params(txtfile)
            except:
                self.params = None
        else:
            if s.shape == (x.size, v.size):
                s = s.T
            elif s.shape != (v.size, x.size):
                raise Exception("The shape of intensity axis does not match those of vaxis and xaxis.")
            self.vaxis = v
            self.xaxis = x
            self.saxis = s
            self.params = params
    
    def show(self, title="", flip=True, **kwargs):
        """
        To-do: a simple method to quickly see the results of the PV model.
        Params:
            title (str): the title of the plot.
        This method does not return anything.
        """
        if self.params is not None:
            axis_unit = self.params["axis_unit"]
        plt_pv(vaxis=self.vaxis, xaxis=self.xaxis, saxis=self.saxis,
               title=title, flip=flip, **kwargs)
        
    def add_contour(self, ax, smooth=None, levels=[0.1, 0.3, 0.5, 0.7, 0.9], x_offset=False, 
                    vsys=0, flip=False, transpose=False, colors='k', **kwargs):
        """
        To-do: add the model data as contour on top of the given image. 
        Params:
            ax (matplotlib.axes.Axes or imfits._imfits.Imfits): the image to which the contour is drawn
            clevels (array-like): the contour levels
            x_offset (bool): True to set offset as the x axis and velocity as the y axis.
        Return:
            ax (matplotlib.axes.Axes): the image with contour drawn
        """
        saxis = self.saxis.copy()
        saxis = saxis.T if transpose else saxis
        saxis = np.flipud(saxis) if flip else saxis
        
        if smooth is not None:
            saxis = gaussian_filter(saxis, smooth)
            
        if self.vaxis is None or self.xaxis is None or self.saxis is None:
            raise Exception("You must first create a model using 'pvsim.PVModel'.")
        if x_offset:
            extent = [self.xaxis.min(), self.xaxis.max(), self.vaxis.min()+vsys, self.vaxis.max()+vsys]
            ax.contour(saxis, extent=extent, levels=np.array(levels)*np.nanmax(saxis), colors=colors, **kwargs)
        else:
            extent = [self.vaxis.min()+vsys, self.vaxis.max()+vsys, self.xaxis.min(), self.xaxis.max()]
            ax.contour(saxis.T, extent=extent, levels=np.array(levels)*np.nanmax(saxis), colors=colors, **kwargs)
        plt.show()
        return ax
    
    def plt_residual(self, x, v=None, data=None, threshold=None, **kwargs):
        """
        To-do: create a residual plot from the input data and obtain the residual data. 
                The model data are normalized to the same range as observational data.
                If one arguemnt is given, it will be treated as an imfits._imfits.Imfits object.
        Params:
            x (ndarray): the x values of the observational data, or simply an imfits._imfits.Imfits object.
            v (ndarray): the v values of the observational data (km/s)
            data (ndarray): the intensity values of the observational data (Jy/beam)
        Returns:
            residual (ndarray): the residual array (observed - model)
        """
        if v is None and data is None:
            if isinstance(x, np.ndarray):
                raise Exception("If one argument is given, it must be an imfits._imfits.Imfits object.")
            image = copy.deepcopy(x)
            x = image.xaxis
            v = image.vaxis
            data = image.data
        
        self.xaxis = np.round(self.xaxis, 6)
        self.vaxis = np.round(self.vaxis, 6)
        
        x = np.round(x, 6)
        v = np.round(v, 6)
        
        if np.round(x[1] - x[0], 6) != np.round(self.xaxis[1] - self.xaxis[0], 6) or np.round(v[1] - v[0], 6) != np.round(self.vaxis[1] - self.vaxis[0], 6):
            raise Exception("The model must have the same number of pixels as the data.")
        
        if self.vaxis is None or self.xaxis is None or self.saxis is None:
            raise Exception("You must first create a model using 'pvsim.make_model' or 'pvsim.PVModel'.")
        if data.shape != (v.size, x.size):
            data = data.reshape((v.size, x.size))
        
        # Set threshold:
        if threshold is not None:
            data = np.where(data<threshold, np.nan, data)
        
        # Normalize to the same range:
        saxis = self.saxis * (np.nanmax(data)-np.nanmin(data)) + np.nanmin(data)
        
        # Find the overlapping range for x and v
        xmin, xmax = max(self.xaxis.min(), x.min()), min(self.xaxis.max(), x.max())
        vmin, vmax = max(self.vaxis.min(), v.min()), min(self.vaxis.max(), v.max())

        # Indices for the overlapping range
        x_idx = (xmin <= self.xaxis) & (self.xaxis <= xmax)
        v_idx = (vmin <= self.vaxis) & (self.vaxis <= vmax)
        xx_idx = (xmin <= x) & (x <= xmax)
        vv_idx = (vmin <= v) & (v <= vmax)

        # Crop the model data
        saxis = saxis[v_idx][:, x_idx]

        # Crop the observational data
        data = data[np.ix_(vv_idx, xx_idx)]
        
        # Compute the residual
        residual = np.flipud(data - saxis)
        
        rss = np.nansum(np.square(residual))
        
        print(f"RSS: {rss}")
        
        plt_pv(vaxis=self.vaxis[v_idx],
               xaxis=self.xaxis[x_idx],
               saxis=residual,
               title="Residual",
               cbar_label="Intensity (Jy beam$^{-1}$)", 
               **kwargs)
        
        return residual
    
    def export_txt(self, filename):
        if (os.path.isfile(filename) or os.path.exists(filename) or os.path.isfile(filename+".txt") or os.path.exists(filename+".txt")):
            num = 2
            while True:
                if (os.path.isfile(filename+f"({num})") or os.path.exists(filename+f"({num})") or os.path.isfile(filename+f"({num}).txt") or os.path.exists(filename+f"({num}).txt")):
                    num += 1
                else:
                    break
        filename += f"({num})"
        if not filename.endswith(".txt"):
            filename += ".txt"
        if self.params is None:
            lines = 28 * [" "]
        else:
            lines = ["params = {"] + [f"'{key}': '{value}'," for key, value in params.items()] + ["}"]
            lines += 9 * [" "]
        lines +=  [f"saxis = np.array({str(self.saxis.tolist())})"] + [" "]
        lines += [f"vaxis = np.array({str(self.vaxis.tolist())})"] + [" "]
        lines += [f"xaxis = np.array({str(self.xaxis.tolist())})"]
        print(f"Saving data to '{filename}'...")
        with open(filename, "w") as f:
            f.write("\n".join(lines))
    
    def normalize(self, inplace=False):
        saxis = self.saxis.copy()
        vaxis = self.vaxis.copy()
        xaxis = self.xaxis.copy()
        params = copy.deepcopy(self.params)
        
        new_saxis = (saxis - np.nanmin(saxis))/(np.nanmax(saxis)-np.nanmin(saxis))
        
        if inplace:
            self.saxis = new_saxis
        return PVModel(v=vaxis, s=new_saxis, x=xaxis, params=params)
    
    # To-do:
#     def minmax_vel(self, ax=None):
#         # get axes
#         xaxis = self.xaxis
#         vaxis = self.vaxis
#         saxis = self.saxis
        
#         # create grid and obtain min & max velocities
#         vv, xx = np.meshgrid(vaxis, xaxis, indexing='ij')
#         vv = np.where((np.isnan(saxis))|(saxis == 0), np.nan, vv)
#         minvel = np.nanmin(vv, axis=0)
#         maxvel = np.nanmax(vv, axis=0)
        
#         # add contour on axis:
#         if axis is not None:
#             ax.contour(minvel, )
        
#         return minvel, maxvel


# -

class DatacubeModel:
    def __init__(self, txtfile=None, v=None, x=None, y=None, s=None, 
                 beam=None, params=None, reorg=True, **kwargs):
        """
        This is the constructor of the DatacubeModel class. 
        There are three ways to create a DatacubeModel object:
        1. Use the "txtfile" parameter to import the axes from a textfile generated by this module. 
        2. Manually set the vaxis, xaxis, yaxis, and saxis.
        3. Apply keywords arguments consistent with the 'make_datacube_model' function. 
        """
        if (v is None or x is None or s is None) and txtfile is None:
            if 'ret_params' in kwargs:
                kwargs.pop("ret_params")
                self.xaxis, self.yaxis, self.vaxis, self.saxis, self.params = make_datacube_model(ret_params=True, **kwargs)
                if self.saxis.shape != (self.vaxis.size, self.xaxis.size, self.yaxis.size):
                    self.saxis = self.saxis.reshape(self.vaxis.size, self.xaxis.size, self.yaxis.size)
                self.beam = beam
            else:
                self.xaxis, self.yaxis, self.vaxis, self.saxis, self.params = make_datacube_model(ret_params=True, **kwargs)
                self.beam = beam
        elif txtfile is not None:
            self.vaxis, self.xaxis, self.yaxis, self.saxis = import_data(txtfile)
            self.params = import_params(txtfile)
            self.beam = beam
        else:
            if s.shape != (v.size, x.size, y.size) and x.size in s.shape and y.size in shape and v.size in shape:
                s = s.reshape(v.size, x.size, y.size)
                self.vaxis = v  # 1d
                self.xaxis = x  # 1d
                self.yaxis = y  # 1d
                self.saxis = s  # 3d
                self.params = params
                self.beam = beam
            elif s.shape == (v.size, x.size, y.size):
                self.vaxis = v  # 1d
                self.xaxis = x  # 1d
                self.yaxis = y  # 1d
                self.saxis = s  # 3d
                self.params = params
                self.beam = beam
            else:
                raise Exception("The shape of intensity axis does not match those of vaxis and xaxis.")
        if self.beam is not None and len(self.beam) != 3:
            raise Exception("The input for beam size must contain [bmaj, bmin, pa].")
        if reorg:
            self.saxis = self.saxis.reshape(self.xaxis.size, self.yaxis.size, self.vaxis.size)
            self.saxis = np.array([self.saxis[:,:,i] for i in range(self.vaxis.size)])
            print("NOTE: If you encounter any issues with plotting, try setting 'reorg' parameter as False.")
        else:
            print("NOTE: If you encounter any issues with plotting, try setting 'reorg' parameter as True.")
            
    def show(self, axis_unit=None, **kwargs):
        """
        This is a method to quickly plot the datacube model in channel maps. 
        Parameters:
            axis_unit (str): the unit of the positional axes. 
            **kwargs: other keyword arguments compatible with the channel map function.
        This function does not return anything.
        """
        if self.params is not None and axis_unit is None:
            axis_unit = self.params["axis_unit"] 
            if 'beam' in kwargs:
                channelmaps(xaxis=self.xaxis, yaxis=self.yaxis, vaxis=self.vaxis, 
                            saxis=self.saxis, **kwargs)
            else:
                channelmaps(xaxis=self.xaxis, yaxis=self.yaxis, 
                            vaxis=self.vaxis, saxis=self.saxis, 
                            beam=self.beam, **kwargs)
        else:
            axis_unit = "arcsec" if axis_unit is None else axis_unit
            if 'beam' in kwargs:
                channelmaps(xaxis=self.xaxis, yaxis=self.yaxis, 
                            vaxis=self.vaxis, saxis=self.saxis, 
                            axis_unit=axis_unit, **kwargs)
            else:
                channelmaps(xaxis=self.xaxis, yaxis=self.yaxis, 
                            vaxis=self.vaxis, saxis=self.saxis, 
                            axis_unit=axis_unit, beam=self.beam, **kwargs)

    def gauss_convolve(self, bmaj, bmin=None, pa=0, scale=1, save_totalflux=False, inplace=False):
        """
        Perform Gaussian Convolution on the channel maps.
        Parameters:
            bmaj (float): Major axis size in arcsec.
            bmin (float): Minor axis size in arcsec. 
                          If None, it will be same to the major axis size (Circular Gaussian)
            pa (float): Position angle of the Gaussian
            scale (float): The sizes will be multiplied by this value.
            save_totalflux (boolean): If true, the total flux of that channel will be conserved.
            inplace (boolean): If true, the saxis of the object will be updated directly.
        Returns:
            if inplace is specified as False:
                a new DatacubeModel object with convolved saxis will be returned.
        """
        # get axes:
        saxis = self.saxis.copy()
        xaxis = self.xaxis.copy()
        yaxis = self.yaxis.copy()
        vaxis = self.vaxis.copy()
        saxis = np.where(np.isnan(saxis), 0, saxis)
        
        bmin = bmaj if bmin is None else bmin

        # Calculate pixel scale
        pixel_scale_x = np.abs(xaxis[1] - xaxis[0])
        pixel_scale_y = np.abs(yaxis[1] - yaxis[0])
        pixel_scale = (pixel_scale_x + pixel_scale_y) / 2  # Average pixel scale

        # Multiply bmaj and bmin by scale, then convert to standard deviation in pixels
        sigma_x = (bmaj * scale) / (pixel_scale * 2 * np.sqrt(2 * np.log(2)))
        sigma_y = (bmin * scale) / (pixel_scale * 2 * np.sqrt(2 * np.log(2)))

        # Perform Gaussian convolution
        convolved_saxis = np.empty_like(saxis)
        for channel in range(vaxis.size):
            if save_totalflux:
                total_flux_before = np.sum(saxis[channel])
            convolved_saxis[channel] = gaussian_filter(saxis[channel], sigma=[sigma_y, sigma_x])
            if save_totalflux:
                total_flux_after = np.sum(convolved_saxis[channel])
                convolved_saxis[channel] *= total_flux_before / total_flux_after

        # Update the beam size
        new_beam = [bmaj, bmin, pa]

        if inplace:
            self.saxis = convolved_saxis
            self.beam = new_beam
        else:
            return DatacubeModel(v=vaxis, x=xaxis, y=yaxis, 
                                 s=convolved_saxis, beam=new_beam, params=self.params, reorg=False)
        
    def transpose(self, inplace=False):
        """
        To-do: to transpose the saxis of the datacube model. 
        Parameters:
            inplace: True to modify the current model's saxis. 
        Return:
            if inplace is set to False, a new DatacubeModel object will be returned.
        """
        trans_saxis = saxis.copy()
        for i in range(vaxis.size):
            trans_saxis[i,:,:] = trans_saxis[i,:,:].T
        if inplace:
            self.saxis = trans_saxis
        else:
            return DatacubeModel(v=self.vaxis, x=self.xaxis, y=self.yaxis, s=self.saxis, 
                                 params=self.params, beam=self.beam)
        
    def flip(self, updown=True, inplace=False):
        """
        To-do: to flip the saxis of the datacube model.
        Parameters:
            updown (bool): True to flip the saxis from up to down. False to flip from left to right.
            inplace: True to modify the current model's saxis.
        Return:
            if inplace is set to False, a new DatacubeModel object will be returned.
        """
        flipped_saxis = self.saxis.copy()
        if updown:
            for i in range(vaxis.size):
                flipped_saxis[i,:,:] = np.flipud(flipped_saxis[i,:,:])
        else:
            for i in range(vaxis.size):
                flipped_saxis[i,:,:] = np.fliplr(flipped_saxis[i,:,:])
        if inplace:
            self.saxis = flipped_saxis
        else:
            return DatacubeModel(v=self.vaxis, x=self.xaxis, y=self.yaxis, 
                                 s=flipped_saxis, params=self.params, beam=self.beam)
        
    def reorg(self):
        """
        To-do: to reorganize the saxis. 
        Apply this method if you encounter any issues with plotting or gaussian convolution.
        This method does not return anything.
        """
        self.saxis = self.saxis.reshape(self.xaxis.size, self.yaxis.size, self.vaxis.size)
        self.saxis = np.array([self.saxis[:,:,i] for i in range(self.vaxis.size)])
        
    def export_txt(self, filename):
        """
        To-do: to export the data into a text file.
        Parameters:
            filename: the name of the file. If the filename already exists, 
                    (n) will be added to the filename.
        This method does not return anything.
        """
        if (os.path.isfile(filename) or os.path.exists(filename) or os.path.isfile(filename+".txt") or os.path.exists(filename+".txt")):
            num = 2
            while True:
                if (os.path.isfile(filename+f"({num})") or os.path.exists(filename+f"({num})") or os.path.isfile(filename+f"({num}).txt") or os.path.exists(filename+f"({num}).txt")):
                    num += 1
                else:
                    break
        filename += f"({num})"
        if not filename.endswith(".txt"):
            filename += ".txt"
        if self.params is None:
            lines = 25 * [" "]
        else:
            lines = ["params = {"] + [f"'{key}': '{value}'," for key, value in params.items()] + ["}"]
            lines += 9 * [" "]
        lines +=  [f"saxis = np.array({str(self.saxis.tolist())})"] + [" "]
        lines += [f"vaxis = np.array({str(self.vaxis.tolist())})"] + [" "]
        lines += [f"xaxis = np.array({str(self.xaxis.tolist())})"] + [" "]
        lines += [f"yaxis = np.array({str(self.yaxis.tolist())})"]
        
        print(f"Saving data to '{filename}'...")
        with open(filename, "w") as f:
            f.write("\n".join(lines))   
    
    def normalize(self, inplace=False):
        """
        This method will normalize the saxis. If inplace is set to True, 
        the transformation will be performed on the current object. Otherwise, 
        a new object with transformed saxis will be returned.
        """
        saxis = self.saxis.copy()
        saxis = (saxis - np.nanmin(saxis))/(np.nanmax(saxis)-np.nanmin(saxis))
        if inplace:
            self.saxis = saxis
        else:
            return DatacubeModel(v=self.vaxis, x=self.xaxis, y=self.yaxis, 
                                 s=saxis, params=self.params, beam=self.beam)
            
    def add_contour(self, data, x=None, y=None, v=None, 
                    vlim=[], xrange=None, center=[0, 0], 
                    axis_unit="arcsec", ncol=5, 
                    levels=[0.1, 0.3, 0.5, 0.8],
                    vsys=0,
                    vmin=None, vmax=None,
                    ccolor='k', cmap='rainbow',
                    txtcolor="w",
                    **kwargs):
        """
        To-do: To add contour the modelled channel maps as contour on the observed channel maps. 
                The beam size will be plotted on the left corner of the left corner subplot if self.beam is not None.
        Parameters:
            data (3d array): 
                    The channel maps on which the contour will be drawn or the datacube. 
                    If x, y, or v is set to 'None', this parameter will be read as a grid. 
                    Otherwise, it will be interpreted as the saxis (intensity axis) of the datacube.
            x (ndarray): the xaxis of the observed channel maps. 
            y (ndarray): the yaxis of the observed channel maps. 
            v (ndarray): the vaxis of the observed channel maps. 
            levels (iterable): the contour levels that will be drawn on each channel map.
            vlim (iterable): The upper and lower limits of the radial velocity (km/s) 
                             of the channels on which the contour will be drawn. 
                             Default is to draw all available channels (total number == v.size 
                             or number of subplots in the grid).
            xrange (float): The range on which the channel maps will be drawn. 
                            For example, if xrange == 3, the xlim (RA) and ylim (Dec) will be:
                            [center[0]+3, center[0]-3] and [center[1]-3, center[1]+3]
            center (iterable[float]): the coordinates of the center of each channel map. 
                                          The contours will also be centered on this position.
                                          Default is to use the default center. len(center) == 2 unless default.
            axis_unit (float): the unit of the x and y axes. Default is to use 'arcsec'.        
        """
        
        # get axes
        saxis = self.saxis.copy()
        xaxis = self.xaxis.copy()
        yaxis = self.yaxis.copy()
        vaxis = np.round(self.vaxis.copy(), 4)
        if x is not None and y is not None and v is not None:
            s = data.copy()
            x = x.copy()
            y = y.copy()
            v = np.round(v.copy(), 4)
        else:
            s = data.data.copy()
            x = (data.xaxis.copy()*u.deg).to(u.arcsec).value
            y = (data.yaxis.copy()*u.deg).to(u.arcsec).value
            v = np.round(data.vaxis.copy(), 4)
        
        beam = self.beam
        
        # Change Settings
        cm_settings()
        
        # Check the shape of saxis
        expected_shape = (vaxis.size, xaxis.size, yaxis.size)
        if saxis.shape != expected_shape:
            # Print diagnostic information
            print(f"Warning: saxis shape {saxis.shape} does not match expected shape {expected_shape}. Attempting to reshape...")
            try:
                saxis = saxis.reshape(expected_shape)
            except ValueError as e:
                print(f"Error reshaping saxis: {e}")
                return None # Return early if reshaping fails
        else:
            print(f"saxis shape is correct: {expected_shape}")
        
        expected_shape = (v.size, x.size, y.size)
        if s.shape != expected_shape:
            # Print diagnostic information
            print(f"Warning: data shape {s.shape} does not match expected shape {expected_shape}. Attempting to reshape...")
            try:
                s = s.reshape(expected_shape)
            except ValueError as e:
                print(f"Error reshaping data: {e}")
                return None # Return early if reshaping fails
        else:
            print(f"data shape is correct: {expected_shape}")
        
        model_channels = np.arange(vaxis.size)
        data_channels = np.arange(v.size)
        valid_data_channels = data_channels[(vaxis.min()<=v)&(v<=vaxis.max())]
        v = v[valid_data_channels[0]: valid_data_channels[-1]+1]
        s = s[valid_data_channels[0]: valid_data_channels[-1]+1, :,:]
        
        if len(vlim) == 2:
            if vlim[0] > vlim[1]:
                vlim[0], vlim[1] = vlim[1], vlim[0]
            valid_data_channels = valid_data_channels[(vlim[0]<=v)&(v<=vlim[1])]
            s = s[(vlim[0]<=v)&(v<=vlim[1])]
            saxis = saxis[(vlim[0]<=v)&(v<=vlim[1])]
            vaxis = vaxis[(vlim[0]<=v)&(v<=vlim[1])]
            v = v[(vlim[0]<=v)&(v<=vlim[1])]
        
        print(f"Included channels: {v.tolist()} km/s")
        
        nchannels = valid_data_channels.size
        nrow = int(np.ceil(nchannels/ncol))

        fig = plt.figure(figsize=(ncol * 5 + 1, nrow * 5))
        spec = gridspec.GridSpec(nrow, ncol + 1, wspace=0, hspace=0, width_ratios=[1] * ncol + [0.05])

        # Create a shared colorbar axis
        cbar_ax = fig.add_subplot(spec[:, -1])

        if vmin is None:
            vmin = np.nanmin(s[valid_data_channels[0]:valid_data_channels[-1]+1, :, :])
        if vmax is None:
            vmax = np.nanmax(s[valid_data_channels[0]:valid_data_channels[-1]+1, :, :])
        if vmin > vmax:
            vmin, vmax = vmax, vmin

        for idx, channel in enumerate(valid_data_channels):
            row = idx // ncol
            col = idx % ncol
            
            ax = fig.add_subplot(spec[row, col])
            
            im = ax.imshow(np.flipud(s[idx, :, :]), cmap=cmap, 
                           extent=[x.max()-center[0], x.min()-center[0], y.min()-center[1], y.max()-center[1]], 
                           vmin=vmin, vmax=vmax, rasterized=True, 
                           **kwargs)
            
            clevels = np.nanmax(saxis[idx, :, :])*np.array(levels)
            
            ax.contour(saxis[idx, :, :].T, 
                       levels=clevels, 
                       extent=[xaxis.max(), xaxis.min(), yaxis.min(), yaxis.max()], 
                       colors=ccolor,
                       zorder=9,
                       **kwargs)
            
            # Plot vaxis value on the top right corner
            ax.text(0.95, 0.95, f'{vaxis[idx]:.2f} km/s', ha='right', 
                    va='top', transform=ax.transAxes, color=txtcolor, fontsize=25)

            # Plot x and y labels on the bottom left corner
            if row == nrow - 1 and col == 0:
                ax.set_xlabel(f'Relative RA ({axis_unit})')
                ax.set_ylabel(f'Relative Dec ({axis_unit})')
                if beam is not None:
                    add_beam(ax, bmaj=beam[0], bmin=beam[1], bpa=beam[2], 
                             bcolor=txtcolor, loc='bottom left')
            else:
                ax.set_xticks([])
                ax.set_yticks([])
            
            if xrange is not None:
                ax.set_xlim([xrange, -xrange])
                ax.set_ylim([-xrange, xrange])
            # Remove space between subplots
            ax.set_aspect('auto')

        # Add one colorbar on the right side
        cbar = plt.colorbar(im, cax=cbar_ax)
        cbar.set_label('Intensity (Jy beam$^{-1}$)', fontsize=30)

        print("Drawing maps...", end="")    
        plt.show()


def make_pvmodel(xlim=(-1.4, 1.4, 0.04),
                 ylim=(-1.5, 1.5, 0.01),
                 vlim=(-1.9, 1.9, 0.1),
                 vresol=0.083,
                 resol=0.3,
                 linspace_num=7,
                 max_vel=1.65,
                 cent_barrier=40, # AU
                 inc_angle=0,
                 cav_angle=130,
                 envelope_radius=625,  # AU
                 int_step=0.005,
                 rigid_rot=True,
                 axis_unit="arcsec",
                 distance=403,
                 power_law=-1.5,
                 axis="Major",
                 save_txt=False,
                 filename=None,
                 ret_params=False):
    """
    To-do: generate the PV diagram data (with intensity) using the spherical 
            symmetric assumption, with cones as upper & lower cavity and a disk within centrifugal barrier.
    Parameters:
        xlim (tuple[float]): the limits of the line of sky position axis [AU] (x_start, x_end, x_step). 
                             We recommend setting x_step as the linear/angular 'cell size'.
                             This is always the position along the line of sky, no matter whether 
                             axis == "major" or "minor" is selected.
        ylim (tuple[float]): the limits of the line of sight axis [AU] (y_start, y_end, y_step).
                             y_step can be any small value.
        vlim (tuple[float]): the limits of the vaxis [AU] (v_start, v_end, v_step). 
                             v_step is the velocity width of the channel map. 
        vresol (float): the velocity resolution of the observation [km/s]
        resol (float): the resolution of the observation in the units of 'axis_unit' parameter. 
                       Default (None) is to consider infinite resolution.
        linspace_num (int): the number by which the other plane-of-sky axis is divided within -resol/2 to resol/2.
                            Decrease this number to get a less accurate result but faster program time.
        max_vel (float): the maximum observed (rotational) velocity [km/s] in the PV diagram.
        cent_barrier (float): the centrifugal barrier [AU].
        inc_angle (float): the inclination angle in deg. 0 is edge-on; 90 is face-on.
        cav_angle (float): the angle of cavity in deg. 180 is spatially thin disk. 0 is a sphere without any cavity.
                            We recommend setting the cavity angle to be greater than 150 deg to 
                            minimize small angle approximation error (<10%).
        envelope_radius (float): the radius of the outer envelope [AU].
        int_step (float): the integration step of xsmooth, a continuous positional axis. 
        rigid_rot (bool): True to use rigid rotation assumption inside centrifugal barrier (to avoid dividing by zero). 
        axis_unit (str): the unit of xlim and ylim. Linear or angular units (e.g. AU, arcsec) are allowed.
        distance (float): the distance of the stellar object from observation in parsec. 
                          This parameter will only be relevant if 'axis_unit' parameter is angular.
        power_law (float): the power law assumption for surface density. Default is R_center ** -1.5. 
        axis (str): the axis ('major' or 'minor') on which the PV model is created
        save_txt (bool): True to save output data as a text file. '.txt' can either be included or excluded. 
        filename (str): the name of the textfile if save_txt is set to True. 
                        An exception will be raised if save_txt is False and filename is not None.
        
    Returns:
        xaxis_ret / zaxis_ret (ndarray): the offset axis (in specified unit) of the PV diagram.
        vaxis (ndarray): the velocities along the line of sight (km/s).
        saxis (ndarray): the relative intensity axis, normalized from 0~1 (no unit).
    """
    
    start = time.time()  # start timing program

    warnings.filterwarnings('ignore')  # ignore warnings (dividing by zero, etc.)
    
    # error checking
    if save_txt and (filename is None or filename == ""):
        raise Exception("Filename paremter cannot be None if save_text is set to True.")
    elif filename is not None and (os.path.isfile(filename) or os.path.exists(filename) or os.path.isfile(filename+".txt") or os.path.exists(filename+".txt")):
        num = 2
        while True:
            if (os.path.isfile(filename+f"({num})") or os.path.exists(filename+f"({num})") or os.path.isfile(filename+f"({num}).txt") or os.path.exists(filename+f"({num}).txt")):
                num += 1
            else:
                break
        filename += f"({num})"
        
    params = {"xlim": xlim,   
              "ylim": ylim, 
              "vlim": vlim,
              "vresol": vresol,
              "resol": resol,
              "linspace_num": linspace_num,
              "max_vel": max_vel,
              "cent_barrier": cent_barrier,
              "inc_angle": inc_angle,
              "cav_angle": cav_angle,
              "envelope_radius": envelope_radius,
              "int_step": int_step,
              "rigid_rot": rigid_rot,
              "axis_unit": axis_unit,
              "distance": distance,
              "power_law": power_law,
              "axis": axis}
        
    if linspace_num % 2 == 0:
        linspace_num += 1
    if linspace_num >= 13 and resol is not None:
        print("WARNING: This program might take a over a minute. You can decrease the 'linspace_num' parameter to shorten the program time, although the results will not be as accurate.")
        print()
        
    # physical constants
    G = const.G.cgs

    # assign units
    max_vel *= u.km / u.s
    cent_barrier *= u.AU
    envelope_radius *= u.AU
    inc_angle *= u.deg
    cav_angle *= u.deg
    
    # check error due to small angle approximation
    small_angle_approx_error = (1 - np.cos(90*u.deg-cav_angle/2))/np.cos(90*u.deg-cav_angle/2)
    if small_angle_approx_error > 0.1:
        print(f"WARNING: small angle approx error ~{np.round(100*small_angle_approx_error, 1)}% is greater than 10%")
    else:
        print(f"NOTE: small angle approx error ~{np.round(100*small_angle_approx_error, 1)}%")
    
    # functions to convert angular units to linear units and vice versa.
    def ang2lin_res(ang_resol, distance=distance*u.pc):
        return (distance*np.tan(ang_resol)).to(u.AU)

    def lin2ang_res(lin_resol, distance=distance*u.pc):
        return np.arctan(lin_resol/distance).to(u.arcsec)    

    # other derived values
    spec_ang_mom = (max_vel*cent_barrier / np.cos(inc_angle)).to(u.AU*u.km/u.s)
    stellar_mass = (spec_ang_mom**2 / 2 / G / cent_barrier).to(u.Msun)
    disk_thickness = (2*cent_barrier/np.tan(cav_angle/2)).to(u.AU)
    max_infall_velocity = (G*stellar_mass/spec_ang_mom).to(u.km/u.s)
    max_rot_velocity = 2 * max_infall_velocity
    
    if save_txt:
        derived_params = {"Specific angular momentum": spec_ang_mom,
                          "Stellar mass": stellar_mass,
                          "Disk thickness": disk_thickness,
                          "Max infall velocity": max_infall_velocity,
                          "Max rot velocity": max_rot_velocity
                          }
    
    # print all important values
    if axis != "Major" and axis != "major" and axis != "Minor" and axis != "minor":
        raise Exception(f"Axis parameter '{axis}' not recognized. Available options are 'Major' and 'Minor'.")
    print()
    print(f"############## Important Information ##############")
    print(f"AXIS: Major") if axis == "Major" or axis == "major" else print(f"AXIS: Minor")
    print()
    print(f"RESOLUTION: Infinite") if resol is None else print(f"RESOLUTION: {resol} {axis_unit} (linspace_num={linspace_num})")
    print()
    print(f"PARAMETERS:")
    print(f"Max observed velocity: {np.round(max_vel, 3)}")
    print(f"Centrifugal barrier: {np.round(cent_barrier, 3)} = {np.round(lin2ang_res(cent_barrier), 3)}")
    print(f"Envelope radius: {np.round(envelope_radius, 3)} = {np.round(lin2ang_res(envelope_radius), 3)}")
    print(f"Inclination angle: {np.round(inc_angle, 3)}")
    print(f"Cavity angle: {np.round(cav_angle, 3)}")
    print()
    print(f"DERIVED VALUES:")
    print(f"Stellar mass: {np.round(stellar_mass, 3)}")
    print(f"Specific angular momentum: {np.round(spec_ang_mom, 3)}")
    print(f"Inner disk thickness: {np.round(disk_thickness, 3)} = {np.round(lin2ang_res(disk_thickness), 3)}")
    print(f"Deprojected maximum infall: {np.round(max_infall_velocity, 3)}")
    print(f"Deprojected maximum rotation: {np.round(max_rot_velocity, 3)}")
    print(f"###################################################")
    print()        
    
    # y-axis:
    yaxis = np.arange(ylim[0], ylim[1]+ylim[2], ylim[2]) 
    
    # x and z axes:
    if axis == "major" or axis == "Major":
        x1 = np.arange(xlim[0]-xlim[2], xlim[1], xlim[2])
        x2 = x1 + xlim[2]*2
        xaxis = (x1 + x2)/2
        ret_xaxis = xaxis[:]  # keep original unit to be returned
        xsmooth = np.arange(xaxis[0], xaxis[-1]+int_step, int_step)
        zaxis = np.linspace(-resol/2, resol/2, linspace_num) if resol is not None else np.array([0])
        if np.round(xaxis[-1], 5) != xlim[1]:  # check for OBOB
            print("WARNING: off-by-one bug detected. We recommend setting x-axis upper & lower limits as multiples of step size.")
        # convert positional axes to AU
        if axis_unit != "AU":
            try:
                x1 = eval(f"ang2lin_res(x1*u.{axis_unit}).value")
                x2 = eval(f"ang2lin_res(x2*u.{axis_unit}).value")
                xaxis = eval(f"ang2lin_res(xaxis*u.{axis_unit}).value")
                xsmooth = eval(f"ang2lin_res(xsmooth*u.{axis_unit}).value")
                yaxis = eval(f"ang2lin_res(yaxis*u.{axis_unit}).value")
                zaxis = eval(f"ang2lin_res(zaxis*u.{axis_unit}).value")
            except:
                try:
                    x1 = eval(f"(x1*u.{axis_unit}).to(u.AU).value")
                    x2 = eval(f"(x2*u.{axis_unit}).to(u.AU).value")
                    xaxis = eval(f"(xaxis*u.{axis_unit}).to(u.AU).value")
                    xsmooth = eval(f"(xsmooth*u.{axis_unit}).to(u.AU).value")
                    yaxis = eval(f"(yaxis*u.{axis_unit}).to(u.AU).value")
                    zaxis = eval(f"(zaxis*u.{axis_unit}).to(u.AU).value")
                except:
                    raise Exception(f"Axis unit '{axis_unit}' is not recognized. Try angular or linear unit and check for whitespaces.")
    elif axis == "minor" or axis == "Minor":
        z1 = np.arange(xlim[0]-xlim[2], xlim[1], xlim[2])
        z2 = z1 + xlim[2]*2
        zaxis = (z1 + z2)/2
        ret_xaxis = zaxis[:]  # keep original unit to be returned
        zsmooth = np.arange(zaxis[0], zaxis[-1]+int_step, int_step)
        xaxis = np.linspace(-resol/2, resol/2, linspace_num) if resol is not None else np.array([0])
        if np.round(zaxis[-1], 5) != xlim[1]:  # check for OBOB
            print("WARNING: off-by-one bug detected. We recommend setting x-axis upper & lower limits as multiples of step size.")
        # convert positional axes to AU
        if axis_unit != "AU":
            try:
                z1 = eval(f"(z1*u.{axis_unit}).to(u.AU).value")
                z2 = eval(f"(z2*u.{axis_unit}).to(u.AU).value")
                zaxis = eval(f"(zaxis*u.{axis_unit}).to(u.AU).value")
                zsmooth = eval(f"(zsmooth*u.{axis_unit}).to(u.AU).value")
                yaxis = eval(f"(yaxis*u.{axis_unit}).to(u.AU).value")
                xaxis = eval(f"(xaxis*u.{axis_unit}).to(u.AU).value")
            except:
                try:
                    z1 = eval(f"ang2lin_res(z1*u.{axis_unit}).value")
                    z2 = eval(f"ang2lin_res(z2*u.{axis_unit}).value")
                    zaxis = eval(f"ang2lin_res(zaxis*u.{axis_unit}).value")
                    zsmooth = eval(f"ang2lin_res(zsmooth*u.{axis_unit}).value")
                    yaxis = eval(f"ang2lin_res(yaxis*u.{axis_unit}).value")
                    xaxis = eval(f"ang2lin_res(xaxis*u.{axis_unit}).value")
                except:
                    raise Exception(f"Axis unit '{axis_unit}' is not recognized. Try angular or linear unit and check for whitespaces.")

    # v-axis
    v1 = np.arange(vlim[0]-vresol/2, vlim[1]-vresol/2+vlim[2], vlim[2])
    v2 = v1 + vresol
    vaxis = (v1 + v2)/2
    if np.round(vaxis[-1], 5) != vlim[1]:
        print("WARNING: off-by-one bug detected. We recommend setting v-axis upper & lower limits as multiples of step size. Ignore this message if not applicable.")
    
    if axis == "major" or axis == "Major":
        xx, yy, zz, vv1 = np.meshgrid(xsmooth, yaxis, zaxis, v1, indexing='ij')
    elif axis == "minor" or axis == "Minor":
        xx, yy, zz, vv1 = np.meshgrid(xaxis, yaxis, zsmooth, v1, indexing='ij')
    vv2 = vv1 + vresol
    
    xx_prime = xx
    yy_prime = yy*np.cos(inc_angle) - zz*np.sin(inc_angle)  
    zz_prime = yy*np.sin(inc_angle) + zz*np.cos(inc_angle)  
    
    raxis = np.hypot(xx_prime, yy_prime)
    rcent = np.sqrt(xx_prime**2 + yy_prime**2 + zz_prime**2)
    cos_phi = xx_prime / raxis
    sin_phi = yy_prime / raxis
    sin_theta = zz_prime / rcent
    cos_theta = raxis / rcent
    
    # velocities
    inf_vel_mag = np.sqrt(2*G*stellar_mass/(rcent*u.AU) - np.square(spec_ang_mom/(raxis*u.AU))).to(u.km/u.s).value
    inf_vel = inf_vel_mag * (cos_theta*sin_phi*np.cos(inc_angle) - sin_theta*np.sin(inc_angle))
    rot_vel = (spec_ang_mom / (raxis*u.AU) * cos_phi * np.cos(inc_angle)).to(u.km/u.s).value 
    rigid_rot_vel = ((raxis*u.AU)*spec_ang_mom/np.square(cent_barrier)).to(u.km/u.s).value * cos_phi * np.cos(inc_angle)
    
    los_vel = inf_vel + rot_vel
    los_vel = np.where(rcent*u.AU<=envelope_radius, los_vel, np.nan)
    ang_cond = (np.abs(np.arcsin(np.abs((zz_prime*u.AU)/(rcent*u.AU))).to(u.deg)) <= 90*u.deg - cav_angle/2)
    if rigid_rot:
        los_vel = np.where(raxis*u.AU<cent_barrier, np.where(np.abs(zz_prime*u.AU)<disk_thickness/2, rigid_rot_vel, np.nan),
                           np.where(ang_cond, los_vel, np.nan))
    else:
        los_vel = np.where(raxis*u.AU<cent_barrier, np.where(np.abs(zz_prime*u.AU)<disk_thickness/2, los_vel, np.nan),
                           np.where(ang_cond, los_vel, np.nan))
    
    surf_dens = np.where(raxis*u.AU>cent_barrier, np.power(rcent, power_law), np.power(cent_barrier.value, power_law))
    mask = (vv1 <= los_vel) & (los_vel < vv2) & (~np.isnan(los_vel))
    surf_dens = np.where(mask, surf_dens, 0)
    
    # integrate all surface densities along line of sight (yaxis) to obtain column density
    col_dens = np.nansum(surf_dens, axis=1)
    
    if axis == "major" or axis == "Major":
        # average along line of sky (xaxis for major)
        xx, zz, vv = np.meshgrid(xsmooth, zaxis, vaxis, indexing='ij')
        bt = np.array([[[np.mean(col_dens[(x1[i] <= xx) & (xx <= x2[i]) & (zz == zaxis[j]) & (vv == vaxis[k])]) 
                 for k in range(vaxis.size)] 
                for j in range(zaxis.size)] 
               for i in range(xaxis.size)])
        
        # average along the other line of sky (zaxis for major)
        bt = np.mean(bt, axis=1)
        saxis = bt.T
        
    elif axis == "minor" or axis == "Minor":
        # average along line of sky (zaxis for minor)
        xx, zz, vv = np.meshgrid(xaxis, zsmooth, vaxis, indexing='ij')
        bt = np.array([[[np.mean(col_dens[(z1[j] <= zz) & (zz <= z2[j]) & (xx == xaxis[i]) & (vv == vaxis[k])]) 
                 for k in range(vaxis.size)] 
                for j in range(zaxis.size)] 
               for i in range(xaxis.size)])
        
        # average along the other line of sky (xaxis for major)
        bt = np.mean(bt, axis=0)
        saxis = bt.T
        
    # normalize:
    saxis = (saxis - np.nanmin(saxis)) / (np.nanmax(saxis)-np.nanmin(saxis))
    
    # save results to a textfile
    if save_txt:
        filename += ".txt" if not filename.endswith(".txt") else ""
        print()
        print(f"Saving results to '{filename}'...")
        lines = ["params = {"] + [f"'{key}': '{value}'," for key, value in params.items()] + ["}"] + [" "]
        lines += ["derived_params = {"] + [f"'{key}': '{value}'," for key, value in derived_params.items()] + ["}"] + [" "]
        lines += [f"saxis = np.array({str(saxis.tolist())})"] + [" "]
        lines += [f"vaxis = np.array({str(vaxis.tolist())})"] + [" "]
        lines += [f"xaxis = np.array({str(ret_xaxis.tolist())})"]
        with open(filename, "w") as f:
            f.write("\n".join(lines))
    
    # end timer and print program time
    print()
    print(f"Program time: {time.strftime('%M:%S', time.gmtime(np.round(time.time()-start)))}")
    print()
    
    if ret_params:
        return vaxis, ret_xaxis, saxis, params
    
    return vaxis, ret_xaxis, saxis


def make_datacube_model(xlim=(-1.4, 1.4, 0.04),
                        ylim=(-1.5, 1.5, 0.01),
                        vlim=(-1.9, 1.9, 0.1),
                        vresol=0.083,
                        max_vel=1.65,
                        cent_barrier=40, # AU
                        inc_angle=0,
                        cav_angle=130,
                        envelope_radius=625,  # AU
                        int_step=0.005,
                        rigid_rot=False,
                        axis_unit="arcsec",
                        distance=403,
                        power_law=-1.5,
                        save_txt=False,
                        filename=None,
                        ret_params=False):
    
    start = time.time()  # start timing program

    warnings.filterwarnings('ignore')  # ignore warnings (dividing by zero, etc.)
    
    # error checking
    if save_txt and (filename is None or filename == ""):
        raise Exception("Filename paremter cannot be None if save_text is set to True.")
    elif filename is not None and (os.path.isfile(filename) or os.path.exists(filename) or os.path.isfile(filename+".txt") or os.path.exists(filename+".txt")):
        num = 2
        while True:
            if (os.path.isfile(filename+f"({num})") or os.path.exists(filename+f"({num})") or os.path.isfile(filename+f"({num}).txt") or os.path.exists(filename+f"({num}).txt")):
                num += 1
            else:
                break
        filename += f"({num})"
        
    params = {"xlim": xlim,   
              "ylim": ylim, 
              "vlim": vlim,
              "vresol": vresol,
              "max_vel": max_vel,
              "cent_barrier": cent_barrier,
              "inc_angle": inc_angle,
              "cav_angle": cav_angle,
              "envelope_radius": envelope_radius,
              "int_step": int_step,
              "rigid_rot": rigid_rot,
              "axis_unit": axis_unit,
              "distance": distance,
              "power_law": power_law}
        
    # physical constants
    G = const.G.cgs

    # assign units
    max_vel *= u.km / u.s
    cent_barrier *= u.AU
    envelope_radius *= u.AU
    inc_angle *= u.deg
    cav_angle *= u.deg
    
    # other constants
    cos_i = np.cos(inc_angle)
    sin_i = np.sin(inc_angle)
    
    # check error due to small angle approximation
    small_angle_approx_error = (1 - np.cos(90*u.deg-cav_angle/2))/np.cos(90*u.deg-cav_angle/2)
    if small_angle_approx_error > 0.1:
        print(f"WARNING: small angle approx error ~{np.round(100*small_angle_approx_error, 1)}% is greater than 10%.")
    else:
        print(f"NOTE: small angle approx error ~{np.round(100*small_angle_approx_error, 1)}%.")
    
    # functions to convert angular units to linear units and vice versa.
    def ang2lin_res(ang_resol, distance=distance*u.pc):
        return (distance*np.tan(ang_resol)).to(u.AU)

    def lin2ang_res(lin_resol, distance=distance*u.pc):
        return np.arctan(lin_resol/distance).to(u.arcsec)    

    # other derived values
    spec_ang_mom = (max_vel*cent_barrier / cos_i).to(u.AU*u.km/u.s)
    stellar_mass = (spec_ang_mom**2 / 2 / G / cent_barrier).to(u.Msun)
    disk_thickness = (2*cent_barrier/np.tan(cav_angle/2)).to(u.AU)
    max_infall_velocity = (G*stellar_mass/spec_ang_mom).to(u.km/u.s)
    max_rot_velocity = 2 * max_infall_velocity
    
    if save_txt:
        derived_params = {"Specific angular momentum": spec_ang_mom,
                          "Stellar mass": stellar_mass,
                          "Disk thickness": disk_thickness,
                          "Max infall velocity": max_infall_velocity,
                          "Max rot velocity": max_rot_velocity
                          }
    
    # print all important values
    print()
    print(f"############## Important Information ##############")
    print(f"PARAMETERS:")
    print(f"Max observed velocity: {np.round(max_vel, 3)}")
    print(f"Centrifugal barrier: {np.round(cent_barrier, 3)} = {np.round(lin2ang_res(cent_barrier), 3)}")
    print(f"Envelope radius: {np.round(envelope_radius, 3)} = {np.round(lin2ang_res(envelope_radius), 3)}")
    print(f"Inclination angle: {np.round(inc_angle, 3)}")
    print(f"Cavity angle: {np.round(cav_angle, 3)}")
    print()
    print(f"DERIVED VALUES:")
    print(f"Stellar mass: {np.round(stellar_mass, 3)}")
    print(f"Specific angular momentum: {np.round(spec_ang_mom, 3)}")
    print(f"Inner disk thickness: {np.round(disk_thickness, 3)} = {np.round(lin2ang_res(disk_thickness), 3)}")
    print(f"Deprojected maximum infall: {np.round(max_infall_velocity, 3)}")
    print(f"Deprojected maximum rotation: {np.round(max_rot_velocity, 3)}")
    print(f"###################################################")
    print()        
    
    print("Making axes...")
    print()
    # convert positional axes to AU
    if axis_unit != "AU":
        # y-axis:
        yaxis = np.arange(ylim[0], ylim[1]+ylim[2], ylim[2]) 
        # x and z axes:
        x1 = np.arange(xlim[0]-xlim[2], xlim[1], xlim[2])
        x2 = x1 + xlim[2]*2
        xaxis = ret_xaxis = ret_zaxis = (x1 + x2)/2
        xsmooth = np.arange(xaxis[0], xaxis[-1]+int_step, int_step)
        # Check for OBOB
        if np.round(xaxis[-1], 5) != xlim[1]:  
            print("WARNING: off-by-one bug detected. We recommend setting x-axis upper & lower limits as multiples of step size.")
        try:
            x1 = z1 = eval(f"ang2lin_res(x1*u.{axis_unit}).value")
            x2 = z2 = eval(f"ang2lin_res(x2*u.{axis_unit}).value")
            xaxis = zaxis = eval(f"ang2lin_res(xaxis*u.{axis_unit}).value")
            xsmooth = zsmooth = eval(f"ang2lin_res(xsmooth*u.{axis_unit}).value")
            yaxis = eval(f"ang2lin_res(yaxis*u.{axis_unit}).value")
        except:
            try:
                x1 = z1 = eval(f"(x1*u.{axis_unit}).to(u.AU).value")
                x2 = z2 = eval(f"(x2*u.{axis_unit}).to(u.AU).value")
                xaxis = zaxis = eval(f"(xaxis*u.{axis_unit}).to(u.AU).value")
                xsmooth = zsmooth = eval(f"(xsmooth*u.{axis_unit}).to(u.AU).value")
                yaxis = eval(f"(yaxis*u.{axis_unit}).to(u.AU).value")
            except:
                raise Exception(f"Axis unit '{axis_unit}' is not recognized. Try angular or linear unit and check for whitespaces.")
    else:
        # y-axis:
        yaxis = np.arange(ylim[0], ylim[1]+ylim[2], ylim[2]) 
        # x and z axes:
        x1 = z1 = np.arange(xlim[0]-xlim[2], xlim[1], xlim[2])
        x2 = z2 = x1 + xlim[2]*2
        xaxis = zaxis = ret_xaxis = ret_zaxis = (x1 + x2)/2
        xsmooth = zsmooth = np.arange(xaxis[0], xaxis[-1]+int_step, int_step)
        # check for OBOB
        if np.round(xaxis[-1], 5) != xlim[1]:  
            print("WARNING: off-by-one bug detected. We recommend setting x-axis upper & lower limits as multiples of step size.")

    # v-axis
    v1 = np.arange(vlim[0]-vresol/2, vlim[1]-vresol/2+vlim[2], vlim[2])
    vaxis = (2*v1 + vresol)/2
    if np.round(vaxis[-1], 5) != vlim[1]:
        print("WARNING: off-by-one bug detected. We recommend setting v-axis upper & lower limits as multiples of step size. Ignore this message if not applicable.")
    
    xx, yy, zz, vv1 = np.meshgrid(xsmooth, yaxis, zsmooth, v1, indexing='ij')
    vv2 = vv1 + vresol
    
    xx_prime = xx
    yy_prime = yy*cos_i - zz*sin_i
    zz_prime = yy*sin_i + zz*cos_i 
    
    print("Calculating...")
    print()
    raxis = np.hypot(xx_prime, yy_prime)
    rcent = np.sqrt(xx_prime**2 + yy_prime**2 + zz_prime**2)
    cos_phi = xx_prime / raxis
    sin_phi = yy_prime / raxis
    sin_theta = zz_prime / rcent
    cos_theta = raxis / rcent
    
    # velocities
    inf_vel_mag = np.sqrt(2*G*stellar_mass/(rcent*u.AU) - np.square(spec_ang_mom/(raxis*u.AU))).to(u.km/u.s).value
    inf_vel = inf_vel_mag * (cos_theta*sin_phi*cos_i - sin_theta*sin_i)
    rot_vel = (spec_ang_mom / (raxis*u.AU) * cos_phi * cos_i).to(u.km/u.s).value 
    rigid_rot_vel = ((raxis*u.AU)*spec_ang_mom/np.square(cent_barrier)).to(u.km/u.s).value * cos_phi * cos_i
    
    los_vel = inf_vel + rot_vel
    los_vel = np.where(rcent<=envelope_radius.value, los_vel, np.nan)
    ang_cond = (np.abs(np.arcsin(np.abs((zz_prime)/(rcent))).to(u.deg)) <= 90*u.deg - cav_angle/2)
    if rigid_rot:
        los_vel = np.where(raxis<cent_barrier.value, np.where(np.abs(zz_prime)<disk_thickness.value/2, rigid_rot_vel, np.nan),
                           np.where(ang_cond, los_vel, np.nan))
    else:
        los_vel = np.where(raxis<cent_barrier.value, np.where(np.abs(zz_prime)<disk_thickness.value/2, los_vel, np.nan),
                           np.where(ang_cond, los_vel, np.nan))
    
    surf_dens = np.where(raxis>cent_barrier.value, np.power(rcent, power_law), np.power(cent_barrier.value, power_law))
    surf_dens = np.where((vv1 <= los_vel) & (los_vel < vv2) & (~np.isnan(los_vel)), surf_dens, 0)
    
    # integrate all surface densities along line of sight (yaxis) to obtain column density
    col_dens = np.sum(surf_dens, axis=1)
        
    print("Averaging...this might take a while.")
        
    mask_x = (x1[:, None] <= xsmooth) & (xsmooth <= x2[:, None])
    mask_z = (z1[:, None] <= zsmooth) & (zsmooth <= z2[:, None])

    indices_x = np.column_stack([mask_x.argmax(axis=1), (mask_x[:, ::-1]).argmax(axis=1)])
    indices_z = np.column_stack([mask_z.argmax(axis=1), (mask_z[:, ::-1]).argmax(axis=1)])

    # Correcting the indices for reversed search
    indices_x[:, 1] = xsmooth.size - 1 - indices_x[:, 1]
    indices_z[:, 1] = zsmooth.size - 1 - indices_z[:, 1]
    
    saxis = np.array([
        np.mean(col_dens[ix[0]:ix[1], iz[0]:iz[1]], axis=(0, 1))
        for ix in indices_x
        for iz in indices_z
    ]).reshape((vaxis.size, xaxis.size, zaxis.size))
        
    # normalize:
    saxis = (saxis - np.nanmin(saxis)) / (np.nanmax(saxis)-np.nanmin(saxis))
    
    # save results to a textfile
    if save_txt:
        filename += ".txt" if not filename.endswith(".txt") else ""
        print()
        print(f"Saving results to '{filename}'...")
        lines = ["params = {"] + [f"'{key}': '{value}'," for key, value in params.items()] + ["}"] + [" "]
        lines += ["derived_params = {"] + [f"'{key}': '{value}'," for key, value in derived_params.items()] + ["}"] + [" "]
        lines += [f"saxis = np.array({str(saxis.tolist())})"] + [" "]
        lines += [f"vaxis = np.array({str(vaxis.tolist())})"] + [" "]
        lines += [f"xaxis = np.array({str(ret_xaxis.tolist())})"] + [" "]
        lines += [f"yaxis = np.array({str(ret_xaxis.tolist())})"] + [" "]
        with open(filename, "w") as f:
            f.write("\n".join(lines))
    
    # end timer and print program time
    print()
    print(f"Program time: {time.strftime('%M:%S', time.gmtime(np.round(time.time()-start)))}")
    print()

    if ret_params:
        return ret_xaxis, ret_zaxis, vaxis, saxis, params
    return ret_xaxis, ret_zaxis, vaxis, saxis


def plt_pv(vaxis, 
           xaxis, 
           saxis, 
           title="PV Model",
           cbaron=True, 
           cmap="inferno",
           plt_type="color",
           datatable=False,
           use_offset_as_x=False,
           figsize=(6, 4), 
           figlim=None,
           ref_lines=True,
           interpolate=False,
           clevels=None,
           offset_unit="arcsec",
           srange=None,
           transpose=False,
           flip=False,
           line_color="w",
           cbar_label="Relative Intensity"
           ):
    """
    To-do: plot the PV diagram given vaxis, xaxis, and saxis.
    Parameters:
        vaxis (1d array): the velocity axis of the PV diagram [km/s].
        xaxis (1d array): the offset axis of the PV diagram in the specified unit.
        saxis (2d array): the (relative) intensity axis.
        title (str): the title of the plot. 
        cbaron (bool): if True, plot the colorbar on the side.
        cmap (str): the color map of the plot.
        plt_type (str): the type of plot. Available options are "color", "contour," and "contourf".
        datatable (bool): if True, the function will plot the data in a datatable.
        use_offset_as_x (bool): if True, the offset axis label will be plotted on the x axis of the PV diagram.
        figsize (array-like with shape (2,)): the size of the figure. Default is to use (6, 4).
        figlim (array-like with shape (4,)): the limits of the figure given in (xmin, xmax, ymin, ymax). 
                                             Default is to use min & max of given axes.
        ref_lines (bool): True to plot reference lines at x = 0 and y = 0.
        interpolate (bool): True to interpolate the data. Only applicable for plt_type == "contour" or "contourf".
        clevels (1d array-like): list of contour levels to be plotted if plt_type == "contour" or "contourf".
        offset_unit (str): unit of offset axis.
        srange (array-like): the range of the intensity axis. Default to use min & max of given saxis.
        transpose (bool): if True, the saxis will be transposed before plotting.
        flip (bool): if True, the saxis will be flipped across x=0 before plotting.
        line_color (str): the color of the reference lines, if ref_lines == True.
    This function does not return anything.
    """
    saxis = saxis.T if transpose else saxis
    
    # Plot results
    letterratio = 1.294
    nrows = ncols = 1
    width = height = 250
    fig_width_pt  = width*ncols
    fig_height_pt = height*nrows
    inches_per_pt = 1.0/72.27  # Convert pt to inch
    fig_width     = fig_width_pt*inches_per_pt  # width in inches
    fig_height    = fig_height_pt*inches_per_pt # height in inches
    fig_size      = [fig_width, fig_height]
    params = {'axes.labelsize': 12,
              'axes.titlesize': 12,
              'font.size': 12,
              'legend.fontsize': 12,
              'xtick.labelsize': 12,
              'ytick.labelsize': 12,
              'xtick.top': True,   # draw ticks on the top side
              'xtick.major.top': True,
              'figure.figsize': fig_size,
              'figure.dpi': 400,
              'font.family': 'Times New Roman',
              "mathtext.fontset": 'stix', #"Times New Roman"
              'mathtext.tt': 'Times New Roman',
              'axes.linewidth': 2.5,
              'xtick.major.width': 1.0,
              'ytick.major.width': 1.0,
              'xtick.minor.width': 1.0,
              'ytick.minor.width': 1.0,
               'xtick.major.size': 6,
               'ytick.major.size': 6,
                'xtick.minor.size': 4.,
                'ytick.minor.size': 4.,
    }
    rcParams.update(params)
    
    if not use_offset_as_x:
        saxis = saxis.T
    if flip:
        saxis = np.flipud(saxis)
        
    if interpolate and plt_type != "color":
        if use_offset_as_x:
            x, v = np.meshgrid(xaxis[:], vaxis[:])
            points = np.vstack((x.flatten(), v.flatten())).T
            values = saxis[:].flatten()
            grid_x, grid_v = np.mgrid[xaxis[:].min():xaxis[:].max():100j, vaxis[:].min():vaxis[:].max():100j]
            grid_s = griddata(points, values, (grid_x, grid_v), method='cubic')
            xaxis, vaxis, saxis = grid_x[:], grid_v[:], grid_s[:]
        else:
            v, x = np.meshgrid(vaxis[:], xaxis[:])
            points = np.vstack((v.flatten(), x.flatten())).T
            values = saxis[:].flatten()
            grid_v, grid_x = np.mgrid[vaxis[:].min():vaxis[:].max():100j, xaxis[:].min():xaxis[:].max():100j]
            grid_s = griddata(points, values, (grid_v, grid_x), method='cubic')
            vaxis, xaxis, saxis = grid_v[:], grid_x[:], grid_s[:]

    plt.figure(figsize=(6, 4))

    plt.tick_params(which='both',direction='in',bottom=True, top=True, left=True, right=True,
            colors='k',labelrotation=0, labelcolor='k')
    plt.title(title)

    if use_offset_as_x:
        if plt_type == "contourf":
            plt.contourf(xaxis, vaxis, saxis, cmap=cmap, levels=clevels)
        elif plt_type == "contour":
            saxis = saxis.T if interpolate else saxis
            if clevels is None:
                clevels = np.arange(0.2, 1., 0.2)*np.nanmax(saxis)
                print(f"Contour levels: {list(clevels)}")
            plt.contour(saxis, colors="k", origin='lower', extent=[xaxis[0], xaxis[-1], vaxis[0], vaxis[-1]],
                        levels=clevels, linewidths=1.25, alpha=None)
        elif plt_type == "color" or plt_type == "colour":
            plt.imshow(np.flipud(saxis), origin='lower', extent=[xaxis[0], xaxis[-1], vaxis[0], vaxis[-1]], cmap=cmap, aspect='auto')
        plt.xlabel(f'Offset ({offset_unit})') 
        plt.ylabel('Velocity (km/s)')
    else:  
        if plt_type == "contourf":
            plt.contourf(vaxis, xaxis, saxis, cmap=cmap, levels=clevels)
        elif plt_type == "contour":
            saxis = saxis.T if interpolate else saxis
            if clevels is None: 
                clevels = np.arange(0.2, 1., 0.2)*np.nanmax(saxis)
                print(f"Contour levels: {list(clevels)}")
            plt.contour(saxis, colors="k", origin='lower', extent=[vaxis[0], vaxis[-1], xaxis[0], xaxis[-1]],
                        levels=clevels, linewidths=1.25, alpha=None)
        elif plt_type == "color" or plt_type == "colour":
            plt.imshow(np.flipud(saxis), origin='lower', extent=[vaxis[0], vaxis[-1], xaxis[0], xaxis[-1]], cmap=cmap, aspect='auto')
        plt.xlabel('Velocity (km/s)')
        plt.ylabel(f'Offset ({offset_unit})')

    if cbaron: 
        plt.colorbar(label=cbar_label)

    if ref_lines:
        plt.axhline(y = 0, color = line_color, linestyle = '-', linewidth=1)
        plt.axvline(x = 0, color = line_color, linestyle = '-', linewidth=1)

    if figlim is not None:
        if figlim[0] > figlim[1]: 
            figlim[0], figlim[1] = figlim[1], figlim[0]
        if figlim[2] > figlim[3]:
            figlim[2], figlim[3] = figlim[3], figlim[2]
        plt.xlim([figlim[0], figlim[1]])
        plt.ylim([figlim[2], figlim[3]])
    else:
        if use_offset_as_x:
            plt.xlim([xaxis[0], xaxis[-1]])
            plt.ylim([vaxis[0], vaxis[-1]])
        else:
            plt.ylim([xaxis[0], xaxis[-1]])
            plt.xlim([vaxis[0], vaxis[-1]])

    if srange is not None: 
        if srange[0] > srange[1]:
            srange[0], srange[1] = srange[1], srange[0]
        plt.clim(srange[0], srange[1])
    
    if datatable:
        try:
            from IPython.display import display
        except:
            print("Your environment does not support 'IPython.display'. Datatable cannot be shown.")
        finally:
            pd.set_option('display.precision', 3)

            def highlight_cells(val):
                color = 'yellow' if val > 0 else ''
                return 'background-color: {}'.format(color)

            sdt = pd.DataFrame(np.round(saxis, 3))
            if use_offset_as_x:
                sdt.columns = ["%.1f" % x for x in xaxis]
                sdt.index = ["%3f" % v for v in vaxis]
            else:
                sdt.columns = ["%.3f" % v for v in vaxis]
                sdt.index = ["%.1f" % x for x in xaxis]
            sdt = sdt.style.format('{:.3f}', na_rep="-").applymap(highlight_cells)
            display(sdt)
                
    plt.show()


def import_data(filename):
    """
    To-do: This function reads the given filename and returns the vaxis, xaxis, and saxis. 
            The function recursively finds the file, so it can be in any sub-directory within the current directory. 
    Parameters:
        filename (str): The name of the txt file. The file name can either include or exclude ".txt". 
                        The directory of the file can be omitted if it is located in a sub-directory 
                        of the current directory. 
    Returns:
        vaxis (ndarray): the velocity axis [km/s]
        xaxis (ndarray): the offset axis in the specified unit (check file)
        saxis (ndarray): the (relative) intensity axis 
    """
    
    def find_file(file):  # recursively finds file
        for root, dirs, files in os.walk(os.getcwd()):
            if file in files:
                return os.path.join(root, file)
        return None 
    
    # error checking
    if not filename.endswith(".txt"):
        filename += ".txt"
        
    if not os.path.exists(filename):
        maybe_filename = find_file(filename)
        if maybe_filename is not None:
            filename = maybe_filename
        else:
            raise FileNotFoundError(f"Filename '{filename}' does not exist.")
    
    # read file:
    with open(filename, 'r') as f:
        lines = list(f)[:]
    
    # if check which module type is stored by the text file. 
    if len(lines) == 33 and "saxis = " in lines[28] and "vaxis = " in lines[30] and "xaxis = " in lines[32]:
        saxis = eval(lines[28][8:])
        vaxis = eval(lines[30][8:])
        xaxis = eval(lines[32][8:])
        return vaxis, xaxis, saxis
    elif len(lines) == 33 and "saxis = " in lines[25] and "vaxis = " in lines[27] and "xaxis = " in lines[29] and "yaxis = " in lines[31]:
        saxis = eval(lines[25][8:])
        vaxis = eval(lines[27][8:])
        xaxis = eval(lines[29][8:])
        yaxis = eval(lines[31][8:])
        return vaxis, xaxis, yaxis, saxis
    else:
        raise Exception(f"File was not generated by the pvsimulator module.")


def import_params(filename):
    """
    To-do: This function reads the given filename and returns the parameters.
            The function recursively finds the file, so it can be in any sub-directory within the current directory. 
    Parameters:
        filename (str): The name of the txt file. The file name can either include or exclude ".txt". 
                        The directory of the file can be omitted if it is located in a sub-directory 
                        of the current directory. 
    Returns:
        params (dict): the parameters used when the model was made
    """
    def find_file(file):  # recursively finds file
        for root, dirs, files in os.walk(os.getcwd()):
            if file in files:
                return os.path.join(root, file)
        return None 
    
    # error checking
    if not filename.endswith(".txt"):
        filename += ".txt"
        
    if not os.path.exists(filename):
        maybe_filename = find_file(filename)
        if maybe_filename is not None:
            filename = maybe_filename
        else:
            raise FileNotFoundError(f"Filename '{filename}' does not exist.")
    
    # read file:
    with open(filename, 'r') as f:
        lines = list(f)[:]
    
    # error checking:
    if len(lines) == 33 and "saxis = " in lines[28] or "vaxis = " and lines[30] and "xaxis = " in lines[32]:
        params = eval(" ".join(lines[:19])[8:])
        params["xlim"] = eval(params["xlim"])
        params["ylim"] = eval(params["ylim"])
        params["vlim"] = eval(params["vlim"])
        params["vresol"] = float(params["vresol"])
        params["resol"] = float(params["resol"]) if params["resol"] != "None" else None
        params["linspace_num"] = int(params["linspace_num"])
        params["max_vel"] = float(params["max_vel"])
        params["cent_barrier"] = float(params["cent_barrier"])
        params["inc_angle"] = float(params["inc_angle"])
        params["cav_angle"] = float(params["cav_angle"])
        params["envelope_radius"] = float(params["envelope_radius"])
        params["int_step"] = float(params["int_step"])
        params["rigid_rot"] = bool(params["rigid_rot"])
        params["distance"] = float(params["distance"])
        params["power_law"] = float(params["power_law"])
        return params

    elif len(lines) == 33 and "saxis = "in lines[25] and "vaxis = "in lines[27] and "xaxis = "in lines[29] and "yaxis = "in lines[31]:
        params = eval(" ".join(lines[:17])[8:])
        params["xlim"] = eval(params["xlim"])
        params["ylim"] = eval(params["ylim"])
        params["vlim"] = eval(params["vlim"])
        params["vresol"] = float(params["vresol"])
        params["max_vel"] = float(params["max_vel"])
        params["cent_barrier"] = float(params["cent_barrier"])
        params["inc_angle"] = float(params["inc_angle"])
        params["cav_angle"] = float(params["cav_angle"])
        params["envelope_radius"] = float(params["envelope_radius"])
        params["int_step"] = float(params["int_step"])
        params["rigid_rot"] = bool(params["rigid_rot"])
        params["distance"] = float(params["distance"])
        params["power_law"] = float(params["power_law"])
        return params


def exportfits(filename, xaxis, yaxis, vaxis, saxis, axisunit="arcsec"):
    primary_hdu = fits.PrimaryHDU()

    # Create image HDUs for arrays
    xaxis_hdu = fits.ImageHDU(data=xaxis, name='XAXIS')
    yaxis_hdu = fits.ImageHDU(data=yaxis, name='YAXIS')
    vaxis_hdu = fits.ImageHDU(data=vaxis, name='VAXIS')
    saxis_hdu = fits.ImageHDU(data=saxis, name='SAXIS')

    # Create an HDU list
    hdul = fits.HDUList([primary_hdu, xaxis_hdu, yaxis_hdu, vaxis_hdu, saxis_hdu])

    # Write to a FITS file
    if not filename.endswith('.fits'):
        filename += ".fits"
    hdul.writeto(filename, overwrite=True)


def channelmaps(xaxis, yaxis, vaxis, saxis, ncol=5, vlim=[], 
                axis_unit="arcsec", cmap="inferno", vmax=None, vmin=None,
                beam=None, **kwargs):
    """
    To-do: plot the channel maps of a datacube. 
    Parameters:
        xaxis (ndarray): the right ascension axis of each channel map 
        yaxis (ndarray): the declination axis of each channel map
        vaxis (ndarray): the velocity axis of the datacube in km/s
        saxis (ndarray): the 4d intensity axis of all channel maps 
        ncol (int): the number of columns per row
        vlim (iterable): The limits of the velocity axis. 
                        If len(vlim) != 2 non-all-zero channel maps will be plotted.
        axis_unit (str): the angular / linear axis unit (e.g. "arcsec", "au")
    Returns:
        axes: the individual subplots of the channelmap. 
    """
    
    cm_settings()
    
    # Check the shape of saxis
    expected_shape = (vaxis.size, xaxis.size, yaxis.size)
    if saxis.shape != expected_shape:
        # Print diagnostic information
        print(f"Warning: saxis shape {saxis.shape} does not match expected shape {expected_shape}. Attempting to reshape...")
        try:
            saxis = saxis.reshape(expected_shape)
        except ValueError as e:
            print(f"Error reshaping saxis: {e}")
            return None # Return early if reshaping fails
    else:
        print(f"saxis shape is correct: {expected_shape}")
        
    vaxis = np.round(vaxis, 5)
    
    channels = list(range(vaxis.size))
    if len(vlim) != 2:
        valid_channels = [channel for channel in range(vaxis.size) 
                          if not (np.isnan(saxis[channel,:,:]).all()
                          or np.all(saxis[channel,:,:] == 0))]
    else:
        if vlim[0] > vlim[1]:
            vlim[0], vlim[1] = vlim[1], vlim[0]
        valid_channels = [channel for channel in channels if vlim[0] <= vaxis[channel] <= vlim[1]]
    print(f"Included channels: {np.round(vaxis[np.array(valid_channels)],5).tolist()} km/s")
    
    nchannels = len(valid_channels)
    nrow = int(np.ceil(nchannels/ncol))

    fig = plt.figure(figsize=(ncol * 5 + 1, nrow * 5))
    spec = gridspec.GridSpec(nrow, ncol + 1, wspace=0, hspace=0, width_ratios=[1] * ncol + [0.05])

    # Create a shared colorbar axis
    cbar_ax = fig.add_subplot(spec[:, -1])
    
    if vmin is None:
        vmin = np.nanmin(saxis[valid_channels[0]:valid_channels[-1]+1, :, :])
    if vmax is None:
        vmax = np.nanmax(saxis[valid_channels[0]:valid_channels[-1]+1, :, :])
        
    if vmin > vmax:
        vmin, vmax = vmax, vmin
        
    for idx, channel in enumerate(valid_channels):
        row = idx // ncol
        col = idx % ncol
        ax = fig.add_subplot(spec[row, col])
        im = ax.imshow(saxis[channel, :, :].T, cmap=cmap, 
                       extent=[xaxis.max(), xaxis.min(), yaxis.min(), yaxis.max()], 
                       vmin=vmin, vmax=vmax, rasterized=True, **kwargs)
        
        # Plot vaxis value on the top right corner
        ax.text(0.95, 0.95, f'{vaxis[channel]:.2f} km/s', ha='right', 
                va='top', transform=ax.transAxes, color='white', fontsize=30)

        # Plot x and y labels on the bottom left corner
        if row == nrow - 1 and col == 0:
            ax.set_xlabel(f'RA ({axis_unit})')
            ax.set_ylabel(f'Dec ({axis_unit})')
            if beam is not None:
                add_beam(ax, bmaj=beam[0], bmin=beam[1], bpa=beam[2], 
                         bcolor='w', loc='bottom left')
        else:
            ax.set_xticks([])
            ax.set_yticks([])

        # Remove space between subplots
        ax.set_aspect('auto')
        
    # Add one colorbar on the right side
    cbar = plt.colorbar(im, cax=cbar_ax)
    cbar.set_label('Relative Intensity', fontsize=30)
    
    print("Drawing maps...", end="")    
    plt.show()
    
    return fig


def pv_extractor(datacube, axis="x"):
    """
    Task: To extract the PV diagram model from the datacube model.
    Parameters:
        datacube (pvsim.DatacubeModel): the datacube model from which the pv diagram is extracted
        axis (str): "x", "X", "major", "Major" to extract from x-axis / major axis.
                    "y", "Y", "minor", "Minor" to extract from y-axis / minor axis.
    Returns:
        a pvsim.PVModel object, the extracted PV Model.
    """
    saxis = datacube.saxis.copy()
    vaxis = datacube.vaxis.copy()
    xaxis = datacube.xaxis.copy()  # Major axis
    yaxis = datacube.yaxis.copy()  # Minor axis
    
    saxis = saxis.reshape((vaxis.size, xaxis.size, yaxis.size))
    
    if axis == "x" or axis == "X" or axis == "major" or axis == "Major":
        yidx = np.where(np.round(yaxis, 3)==0)[0][0]
        new_s = saxis[:, :, yidx: yidx+1].reshape(vaxis.size, yaxis.size)
        return PVModel(x=xaxis, v=vaxis, s=new_s)
    elif axis == "y" or axis == "Y" or axis == "minor" or axis == "Minor":
        xidx = np.where(np.round(xaxis, 3)==0)[0][0]
        new_s = saxis[:, xidx: xidx+1, :].reshape(vaxis.size, xaxis.size)
        return PVModel(x=xaxis, v=vaxis, s=new_s, params=datacube.params)


def add_beam(ax, bmaj: float, bmin: float, bpa: float,
             bcolor: str = 'k', loc: str = 'bottom left', alpha: float = 1,
             zorder: float = 10, ):
    coords = {'bottom left': (0.1, 0.1),
    'bottom right': (0.9, 0.1),
    'top left': (0.1, 0.9),
    'top right': (0.9, 0.9),
    }
    if loc in coords.keys():
        xy = coords[loc]
    else:
        print('CAUTION\tplot_beam: loc keyword is not correct.')
        return 0
    # plot
    bmin_plot, bmaj_plot = ax.transLimits.transform((0,bmaj)) - ax.transLimits.transform((bmin,0)) # data --> Axes coordinate
    beam = patches.Ellipse(xy=xy,
        width=bmin_plot, height=bmaj_plot, fc=bcolor,
        angle=bpa, transform=ax.transAxes, alpha=alpha, zorder=zorder)
    ax.add_patch(beam)


def cm_settings():
    letterratio = 1.294
    nrows = ncols = 1
    width = height = 250
    fig_width_pt  = width*ncols
    fig_height_pt = height*nrows
    inches_per_pt = 1.0/72.27  # Convert pt to inch
    fig_width     = fig_width_pt*inches_per_pt  # width in inches
    fig_height    = fig_height_pt*inches_per_pt # height in inches
    fig_size      = [fig_width, fig_height]
    params = {'axes.labelsize': 24,
              'font.size': 30,
              'legend.fontsize': 30,
              'xtick.labelsize': 30,
              'ytick.labelsize': 30,
              'xtick.top': True,   # draw ticks on the top side
              'xtick.major.top': True,
              'figure.figsize': fig_size,
              'figure.dpi': 200,
              'font.family': 'Times New Roman',
              "mathtext.fontset": 'stix', #"Times New Roman"
              'mathtext.tt': 'Times New Roman',
              'axes.linewidth': 2.5,
              'xtick.major.width': 1.0,
              'ytick.major.width': 1.0,
              'xtick.minor.width': 1.0,
              'ytick.minor.width': 1.0,
               'xtick.major.size': 6,
               'ytick.major.size': 6,
                'xtick.minor.size': 4.,
                'ytick.minor.size': 4.,
    }
    rcParams.update(params)


def render_configuration(dataset, keep=0.1, linspace_num=100, imshow=True):
    dataset = dataset.flatten() if dataset.ndim != 1 else dataset
    smooth = np.linspace(np.nanmin(dataset), np.nanmax(dataset), linspace_num)
    interval = smooth[1]-smooth[0]
    
    s1 = np.arange(np.nanmin(dataset), np.nanmax(dataset)+interval, interval)
    s2 = np.arange(np.nanmin(dataset)+interval, np.nanmax(dataset)+2*interval, interval)
    if s2.size > s1.size:
        s2 = s2[0:s1.size]
    elif s1.size > s2.size:
        s1 = s1[0:s2.size]
        
    saxis = (s1+s2)/2
    pixels = np.array([dataset[(s1[i]<=dataset)&(dataset<s2[i])&(dataset!=np.nan)].size for i in range(len(saxis))])
    area = np.trapz(x=saxis, y=pixels) * keep
    
    vmin = np.nanmin(dataset)
    
    for i in range(len(pixels)):
        if np.trapz(x=saxis[0:i], y=pixels[0:i]) >= area:
            vmax = saxis[i]
            break
    
    if imshow:
        plt.vlines(vmax, ymin=pixels.min(), ymax=pixels.max(), linestyle='dashed')
        plt.plot(saxis, pixels)
    
    return vmin, vmax
